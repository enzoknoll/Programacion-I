ğŸ“˜ FUNCIONES EN C â€“ TranscripciÃ³n Ordenada
________________________________________
ğŸ§  DefiniciÃ³n de FunciÃ³n
Una FUNCIÃ“N es un subprograma que realiza una tarea determinada y bien acotada a la cual le pasamos datos y nos devuelve datos. 
Esta funciÃ³n se ejecuta cuando se lo llama (llamada a la funciÃ³n)
________________________________________
âœ… Ventajas de Usar Funciones
â€¢	Simplifican la comprensiÃ³n del programa.
â€¢	Permiten aislar errores y depurar mÃ³dulos.
â€¢	Facilitan modificaciones futuras.
â€¢	ReutilizaciÃ³n sin necesidad de revisar nuevamente.
â€¢	Independencia del cÃ³digo por mÃ³dulos.
________________________________________
ğŸ“¦ ModularizaciÃ³n en ProgramaciÃ³n
â€¢ Para resolver un problema complejo de desarrollo de software,
   conviene separarlo en partes mÃ¡s pequeÃ±as, que se puedan diseÃ±ar,
   desarrollar, probar y modificar, de manera sencilla y lo mÃ¡s
   independientemente posible del resto de la aplicaciÃ³n.

â€¢	Divide problemas complejos en partes mÃ¡s pequeÃ±as.
â€¢	Estas partes se llaman mÃ³dulos.
â€¢	Cada mÃ³dulo debe resolver una Ãºnica tarea â†’ cohesiÃ³n alta.
â€¢	Si un mÃ³dulo tiene mÃ¡s de un verbo activo, deberÃ­a dividirse.

ğŸ“¦ Cohecion

   La cohesiÃ³n se refiere a que cada mÃ³dulo del sistema se refiera a
   un Ãºnico proceso o entidad.

   â€¢ A mayor cohesiÃ³n, mejor: el mÃ³dulo en cuestiÃ³n serÃ¡ mÃ¡s sencillo de diseÃ±ar,
   programar, probar y mantener.

________________________________________
ğŸ”— Acoplamiento
â€¢	Mide cuÃ¡n relacionado estÃ¡ un mÃ³dulo con otros.
â€¢	Bajo acoplamiento = mejor diseÃ±o.
â€¢	Se logra reduciendo interacciones y efectos colaterales.
________________________________________
ğŸ” Funcionamiento de main
â€¢	Toda aplicaciÃ³n en C debe tener una funciÃ³n main().
â€¢	El programa comienza ejecutando main.
â€¢	main puede llamar a otras funciones.
â€¢	Las definiciones deben ser independientes entre sÃ­.
________________________________________
ğŸ¯ Argumentos y return
â€¢	Argumentos (o parÃ¡metros): datos que recibe una funciÃ³n.
â€¢	Return: devuelve un Ãºnico valor.
â€¢	Ejemplo:
return [expresiÃ³n];
________________________________________
ğŸ§° Tipos de Funciones
â€¢	Predefinidas: vienen con el lenguaje. Ej: pow().
â€¢	Definidas por el usuario: se crean cuando no hay funciones predefinidas que resuelvan el problema.
________________________________________
ğŸ”§ Procedimientos
â€¢	En C se los implementa como funciones tipo void.
â€¢	No devuelven valor y pueden no tener return.
________________________________________
ğŸ—ƒ Variables
â€¢	Locales: definidas dentro de funciones. Solo existen allÃ­.
â€¢	Globales: definidas fuera de funciones. Visibles en todo el programa.
________________________________________
ğŸ“¤ Pasaje de ParÃ¡metros
â€¢	Por valor: se copia el valor.
â€¢	Por referencia: se pasa la direcciÃ³n (punteros).
________________________________________
ğŸ§± Estructura de una FunciÃ³n
tipo_de_dato nombre_funcion(tipo param1, tipo param2) {
   // instrucciones
   return valor;
}
________________________________________
ğŸ”¡ Ejemplos de CÃ³digo
________________________________________
ğŸ“„ Sin FunciÃ³n

#include <stdio.h>
#include <conio.h>

int main() {
   int x, y, z;
   printf("Ingrese nÃºmero: ");
   scanf("%d", &x);
   printf("Ingrese nÃºmero: ");
   scanf("%d", &y);
   z = x + y;
   printf("La suma es %d", z);
   getch();
   return 0;
}
________________________________________
ğŸ“„ Con FunciÃ³n

#include <stdio.h>
#include <conio.h>

int suma(int a, int b);

int main() {
   int x, y, z;
   printf("Ingrese nÃºmero: ");
   scanf("%d", &x);
   printf("Ingrese nÃºmero: ");
   scanf("%d", &y);
   z = suma(x, y);
   printf("La suma es %d", z);
   getch();
   return 0;
}

int suma(int a, int b) {
   int total = a + b;
   return total;
}
________________________________________
ğŸ“„ FunciÃ³n con parÃ¡metros por referencia
int suma(int *a, int *b) {
   int total = *a + *b;
   return total;
}
________________________________________
ğŸ“„ Procedimiento con void
void imprimeValor() {
   int contador = 5;
   printf("El valor de contador es: %d\n", contador);
}
________________________________________
ğŸ“„ FunciÃ³n que suma un arreglo
#define max 9

int sumoarreglo(int a[], int n) {
   int suma = 0;
   for (int i = 0; i < n; i++) suma += a[i];
   return suma;
}



________________________________________
ğŸ“„ FunciÃ³n promedio

float promedio(int a[], int n) {
   int suma = 0;
   float prom = 0;
   for (int i = 0; i < n; i++) suma += a[i];
   prom = suma / n;
   return prom;
}
________________________________________
ğŸ“„ Resumen de "Registros"

Tema principal: Uso de estructuras (registros) en C para manejar datos compuestos.

âœ… Conceptos Clave:
â€¢	Estructura (struct): Agrupa variables de distintos tipos bajo un solo nombre.

  Una estructura o registro es una estructura de datos
  que agrupa variables que pueden tener tipos
  diferentes.

  Es decir, en una estructura en la que se puede definir datos o valores de diferentes tipos.

  Cada componente de un registro se conoce como
  campo o miembro.

  Los componentes de la estructura se declaran dentro de ella, cada uno
  con su tipo y nombre de variable, los tipos pueden ser diferentes.
  El nombre (tiponuevo) de la estructura se considera como un tipo, no
  una variable.
â€¢	Campo o miembro: Cada variable dentro de una estructura.
â€¢	Arreglos de estructuras: Permiten manejar mÃºltiples registros (ej. varios amigos).

ğŸ› ï¸ Operaciones comunes con estructuras:
â€¢	Cargar, recorrer, buscar, acceder, insertar, eliminar y ordenar elementos dentro de arreglos de estructuras.
  â€¢Cargar un arreglo de estructuras.
  â€¢Recorrer un arreglo de estructuras.
  â€¢Buscar un elemento en particular de estructuras.
  â€¢Acceder a un elemento en una posiciÃ³n determinada.
  â€¢Acceder a una posiciÃ³n determinada y mostrar su contenido.
  â€¢Insertar un nuevo elemento.
  â€¢Eliminar un elemento.

  â€¢Ordenar un arreglo de estructuras.
ğŸ§ª Ejemplos de cÃ³digo:
1.	Estructura bÃ¡sica de un amigo:
struct estructura_amigo {
    char nombre[30];
    char apellido[40];
    char telefono[10];
    int edad;
};


2.	Cargar y mostrar datos de un amigo con scanf.
3.	Arreglo de estructuras para varios amigos:
o	Usando arrays y bucles para almacenar y mostrar mÃºltiples registros.
4.	Calcular el promedio de edad de amigos.
5.	Manejo de cuentas bancarias:
o	Identifica clientes deudores y acreedores segÃºn su saldo.
________________________________________

ğŸ“„ Resumen de "Arreglos"

Tema principal: MÃ©todos de ordenamiento de arreglos.

  â€¢ Ordenar un arreglo:
    Es la operaciÃ³n de ordenar un arreglo en
    algÃºn orden de acuerdo a un criterio de
    ordenamiento.

âœ… ClasificaciÃ³n:

  â€¢ Ordenamientos internos: 
    Son aquellos en los que los valores a ordenar estÃ¡n
    en memoria principal, por lo que se asume que el tiempo que se requiere para
    acceder cualquier elemento sea el mismo (a [1], a [500], etc.).

  â€¢ Ordenamientos externos: 
    Son aquellos en los que los valores a ordenar estÃ¡n
    en memoria secundaria (disco, cinta, cilindro magnÃ©tico, etc.), por lo que se
    asume que el tiempo que se requiere para acceder a cualquier elemento
    depende de la Ãºltima posiciÃ³n accesada (posiciÃ³n 1, posiciÃ³n 500, etc.).

ğŸ” Tipos de Algoritmos:

1.	Intercambio:
  En este tipo de algoritmos se toman los elementos de dos en dos, se comparan y
  se INTERCAMBIAN si no estÃ¡n en el orden adecuado. Este proceso se repite hasta
  que se ha analizado todo el conjunto de elementos y ya no hay intercambios.
  Entre estos algoritmosse encuentran el Burbuja (BubbleSort) y QuickSort

o	Compara elementos dos a dos e intercambia si es necesario.
o	Ejemplos: BubbleSort, QuickSort.

2.	InserciÃ³n:
  En este tipo de algoritmo los elementos que van a ser ordenados
  son considerados uno a la vez.
  Cada elemento es INSERTADO en la posiciÃ³n apropiada con
  respecto al resto de los elementos ya ordenados.
  Entre estos algoritmos se encuentran el de InserciÃ³n Directa,
  ShellSort, InserciÃ³n Binaria y Hashing.

o	Inserta cada elemento en su lugar correspondiente.
o	Ejemplos: InsertionSort, ShellSort.

3.	SelecciÃ³n:
  En este tipo de algoritmos se SELECCIONA o se busca el elemento
  mÃ¡s pequeÃ±o (o mÃ¡s grande) de todo el conjunto de elementos y
  se coloca en su posiciÃ³n adecuada. Este proceso se repite para el
  resto de los elementos hasta que todos son analizados.
  Entre estos algoritmos se encuentra el de SelecciÃ³n Directa.

o	Busca el menor/mayor y lo coloca en su sitio.
o	Ejemplo: SelecciÃ³n Directa.

4.	EnumeraciÃ³n:
  En este tipo de algoritmos cada elemento es comparado contra los
  demÃ¡s. En la comparaciÃ³n se cuenta cuÃ¡ntos elementos son mÃ¡s
  pequeÃ±os que el elemento que se estÃ¡ analizando, generando asÃ­
  una â€œenumeraciÃ³nâ€. El nÃºmero generado para cada elemento
  indicarÃ¡ su posiciÃ³n.

o	Cuenta cuÃ¡ntos elementos son menores para determinar la posiciÃ³n final.

5.	Ãrbol, MergeSort, RadixSort: Otros mÃ©todos internos.

6.	MÃ©todos Externos:
o	Natural merging, Polyphase sort, etc.

ğŸ§µ Cadenas de caracteres en C
En el lenguaje C, las cadenas de caracteres no son un tipo de dato nativo como en otros lenguajes. En su lugar, se representan como arreglos (arrays) de caracteres terminados con un carÃ¡cter especial: el null terminator ('\0'). Esta convenciÃ³n permite al lenguaje saber dÃ³nde termina la cadena.

â€¢ DeclaraciÃ³n e inicializaciÃ³n
DeclaraciÃ³n:
char nombre[20];
Esto crea un arreglo de 20 caracteres.

â€¢ InicializaciÃ³n:
char saludo[] = "Hola Mundo";
El compilador asigna automÃ¡ticamente el tamaÃ±o necesario, incluyendo el carÃ¡cter '\0' al final.

â€¢ Funciones comunes

strlen(cadena): Devuelve la longitud de la cadena (sin contar el '\0').

strcpy(destino, origen): Copia el contenido de una cadena a otra.

strcat(destino, origen): Concatena dos cadenas.

strcmp(cadena1, cadena2): Compara dos cadenas lexicogrÃ¡ficamente.

Estas funciones se encuentran en la biblioteca estÃ¡ndar <string.h> .

ğŸ“ Matrices (arreglos bidimensionales)

Una matriz en C es un arreglo de arreglos, es decir, una estructura que permite almacenar datos en una tabla con filas y columnas. Es Ãºtil para representar datos como tablas, imÃ¡genes o matrices matemÃ¡ticas.

â€¢ DeclaraciÃ³n

tipo nombre[filas][columnas];
Ejemplo:

int matriz[3][4];
Esto crea una matriz de 3 filas y 4 columnas. Los elementos se acceden mediante dos Ã­ndices: matriz[fila][columna].

â€¢ InicializaciÃ³n

int matriz[2][2] = {{1, 2}, {3, 4}};
Operaciones comunes
Acceso a elementos: matriz[1][2] accede al elemento en la segunda fila y tercera columna.

â€¢ Recorrido: Utilizando bucles for anidados para iterar sobre filas y columnas.

ğŸ› ï¸ Procedimientos y funciones
En C, las funciones y procedimientos son bloques de cÃ³digo reutilizables que realizan tareas especÃ­ficas. La diferencia principal radica en si devuelven un valor o no.

â€¢ Funciones

Son bloques de cÃ³digo que realizan una tarea y devuelven un valor. Su declaraciÃ³n incluye un tipo de retorno.

tipo_de_retorno nombre_funcion(parÃ¡metros) {
    // cuerpo de la funciÃ³n
}

Ejemplo:

int sumar(int a, int b) {
    return a + b;
}

â€¢ Procedimientos

En C, los procedimientos se implementan como funciones que no devuelven valor, es decir, su tipo de retorno es void.

void imprimirSaludo() {
    printf("Â¡Hola Mundo!\n");
}

â€¢ Llamada a funciones y procedimientos

Una vez definidos, se pueden invocar en el main o en otras funciones:

int resultado = sumar(3, 4);
imprimirSaludo();
